# generated: 2026-01-30
# System Auto: last updated on: 2026-01-30T19:05:55
# Chapter: CH-004 BuilderInterface

## Chapter Definition

**Chapter ID:** CH-004
**Arc:** Pipeline
**Name:** BuilderInterface
**Status:** Design
**Source:** Session 262 Exploration Analysis

---

## Purpose

Define the BUILD stage module that transforms a plan's Detailed Design into code scaffolding (test stubs, function signatures, file structure) following the proven Module + CLI + Recipe pattern.

---

## Design Foundation (Session 262 Analysis)

### The Pattern That Works

HAIOS already wraps agent behavior into callable interfaces through a layered system:

| Pattern | Example | What It Wraps |
|---------|---------|---------------|
| **Module + CLI + Recipe** | WorkEngine, RequirementExtractor | Python logic → callable from anywhere |
| **Phase-Aware Subagent** | investigation-agent | Agent research → structured output |
| **Config-Driven Loader** | ContextLoader with role-based config | Context selection → injectable content |
| **Multi-Gate Skill** | plan-validation-cycle | Validation sequence → single invocation |

### Key Insight

BUILD doesn't need to be "agent does manual work." It can follow the same pattern as INGEST and PLAN:

```
INGEST: CorpusLoader (module) → RequirementExtractor (module) → RequirementSet
PLAN:   PlannerAgent (module) → WorkPlan
BUILD:  BuildOrchestrator (module) → Artifacts
```

### Current vs Target State

| Stage | Current | Target |
|-------|---------|--------|
| INGEST | Module (clean, portable) | Already done |
| PLAN | Module (clean, portable) | Already done |
| BUILD | Agent in DO phase (tangled) | **Module that generates scaffolding** |
| VALIDATE | Agent in CHECK phase (tangled) | Module for CH-005 |

---

## Proposed Interface (From S26)

```python
build(work_item: WorkItem, context: BuildContext) -> Artifacts
```

### Refined Interface (Session 262)

```python
class BuildOrchestrator:
    """BUILD stage module per S26.

    Transforms plan's Detailed Design into code scaffolding.
    Agent's role in DO phase becomes: fill in generated skeletons.
    """

    def scaffold(self, plan_path: Path) -> Artifacts:
        """Generate test stubs + function signatures from plan.

        Args:
            plan_path: Path to PLAN.md with Detailed Design section.

        Returns:
            Artifacts with file paths and skeleton content.
        """
        pass

    def analyze(self, plan_path: Path) -> ArchitectureRecommendation:
        """Query memory for similar implementations.

        Args:
            plan_path: Path to plan to analyze.

        Returns:
            Recommendations based on prior patterns.
        """
        pass

    def recommend(self, plan_path: Path) -> DependencyGraph:
        """Build module dependency graph.

        Args:
            plan_path: Path to plan.

        Returns:
            Graph of dependencies for build order.
        """
        pass
```

---

## Data Classes

```python
@dataclass
class GeneratedFile:
    """A single file generated by BUILD stage."""
    path: Path
    content: str
    file_type: Literal["test", "module", "config", "docs"]
    skeleton: bool  # True if needs agent to fill in

@dataclass
class Artifacts:
    """Result of BUILD stage per S26."""
    files: List[GeneratedFile]
    build_order: List[Path]  # Dependency-ordered
    changes: List[Dict]  # {file, action: created|modified}

@dataclass
class ArchitectureRecommendation:
    """Memory-informed recommendations."""
    similar_implementations: List[int]  # Memory concept IDs
    suggested_patterns: List[str]
    warnings: List[str]

@dataclass
class DependencyGraph:
    """Module dependency information."""
    nodes: Set[str]
    edges: List[Tuple[str, str]]  # (dependent, dependency)
    build_order: List[str]  # Topological sort
```

---

## CLI Integration

```python
# .claude/haios/modules/cli.py

def cmd_build_scaffold(work_id: str) -> int:
    """Generate code scaffold from plan."""
    from build_orchestrator import BuildOrchestrator

    plan_path = find_plan(work_id)
    orchestrator = BuildOrchestrator()
    artifacts = orchestrator.scaffold(plan_path)

    print(f"Generated {len(artifacts.files)} files")
    for f in artifacts.files:
        print(f"  {f.file_type}: {f.path}")
    return 0
```

---

## Justfile Recipes

```make
# Generate code scaffold from plan (CH-004)
build-scaffold id:
    python .claude/haios/modules/cli.py build-scaffold {{id}}

# Analyze plan for architecture recommendations
build-analyze id:
    python .claude/haios/modules/cli.py build-analyze {{id}}

# Show build dependency order
build-deps id:
    python .claude/haios/modules/cli.py build-deps {{id}}
```

---

## Integration with Pipeline

```
PipelineOrchestrator.run():
    self.ingest()   # IDLE → INGESTING → requirements
    self.plan()     # → PLANNING → work_plan
    self.build()    # → BUILDING → artifacts (NEW)
    self.validate() # → VALIDATING → report (CH-005)
```

The Orchestrator would gain:
- `PipelineState.BUILDING` (already in enum, deferred)
- `build()` method that calls BuildOrchestrator

---

## Agent Role Change

**Before (tangled):**
```
DO Phase: Agent reads plan → writes tests → writes code → iterates
```

**After (modular):**
```
BUILD Stage: BuildOrchestrator.scaffold() → test stubs + signatures
DO Phase: Agent fills in skeleton bodies → iterates on failures
```

This parallels how PlannerAgent works:
- PlannerAgent generates **suggested WorkPlan**
- Operator reviews, WorkEngine creates actual work items
- Agent doesn't start from scratch

Similarly:
- BuildOrchestrator generates **suggested code scaffold**
- Agent fills in the generated skeletons
- Agent doesn't design from scratch in DO phase

---

## Requirements

| ID | Requirement | Criticality |
|----|-------------|-------------|
| R0 | BuildOrchestrator class in `modules/build_orchestrator.py` | MUST |
| R1 | `scaffold()` method parses plan's Detailed Design | MUST |
| R2 | Returns Artifacts dataclass with files and build_order | MUST |
| R3 | CLI command `build-scaffold` | MUST |
| R4 | Justfile recipe `build-scaffold` | MUST |
| R5 | Integration with PipelineOrchestrator (optional) | SHOULD |
| R6 | `analyze()` method queries memory for patterns | SHOULD |
| R7 | `recommend()` method builds dependency graph | SHOULD |

---

## Exit Criteria

- [ ] BuildOrchestrator module exists with scaffold() method
- [ ] CLI and justfile integration complete
- [ ] Tests verify scaffold generation from sample plan
- [ ] Agent can use scaffolded output in DO phase

---

## Open Questions

1. **How much should scaffold() generate?**
   - Option A: Just file paths and empty functions
   - Option B: Test assertions based on plan's "Tests First" section
   - Option C: Full skeleton with docstrings from plan

2. **Should this integrate with PipelineOrchestrator or stay separate?**
   - Integration: Full pipeline flow
   - Separate: Agent invokes manually during DO phase

3. **Memory integration depth?**
   - Minimal: No memory queries
   - Medium: Query for similar patterns
   - Deep: Inject learned code snippets

---

## References

- @.claude/haios/epochs/E2/architecture/S26-pipeline-architecture.md
- @.claude/haios/epochs/E2_3/arcs/pipeline/ARC.md
- @.claude/haios/modules/planner_agent.py (pattern to follow)
- @.claude/haios/modules/pipeline_orchestrator.py (integration point)
- Session 262: Exploration analysis of existing patterns
